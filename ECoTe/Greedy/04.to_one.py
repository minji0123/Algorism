# 문제4 1이 될 때까지
# n 이 1이 될 때까지 다음 두 과정 중 하나를 반복적으로 선택하여 수행한다. (2 는 n 이 k 로 나누어 떨어질 때만 선택한다.)
# 1. n 에서 1을 뺍니다.
# 2. n 을 k 로 나눕니다.
# n:17, k:4 -> n:16, k:4 -> n:4, k:4 -> n:1, k:4
# 25 5 => 2

####################################################

# n, k 를 공백을 기준으로 구분하여 입력 받기
n, k = map(int, input().split())

# 연산을 수행하는 횟수
count = 0

# while 문 시작
while True:
    # n 이 k 로 나누어 떨어지는 수가 될 때까지 빼기
    ##################################
    # n 이 k 로 나누어 떨어지지 않아도 k 로 나누어 떨어지는 가장 근접한 수를 저장한다.
    target = (n // k) * k
    # 현재 수가 target 이 되기위해 1을 빼는 연산을 총 몇 번 해야 하는지를 계산해서 넣어줌
    count += (n - target)
    # 1 빼는걸 위에서 수행했으니까 n 을 target 으로 변경해줌
    n = target
    ##################################
    # n 이 k 보다 작을 때 반복문 탈출 (더 이상 나눌 수 없을 때)
    if n < k:
        break
    ##################################
    # k 로 나누기 (연산 한번 한거니까 result +1 해주기)
    count += 1
    n //= k
# while 문 끝

# 마지막으로 남은 수에 1을 빼기 (어차피 n 이 1이면 0이니까 count 안올라감)
count += (n - 1)
print(n, k, count)